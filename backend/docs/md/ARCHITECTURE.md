# Архитектура проекта Arc

## Обзор

Проект построен на принципах **Clean Architecture** с четким разделением на слои и зависимостями, направленными внутрь.

## Структура слоев

```
┌─────────────────────────────────────────┐
│         Presentation Layer              │
│         (handlers)                      │
│  HTTP handlers, request/response models │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│       Application Layer                 │
│       (usecases)                        │
│  Бизнес-логика, orchestration           │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│         Domain Layer                    │
│         (models)                        │
│  Доменные модели, бизнес-правила        │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│      Infrastructure Layer               │
│      (repositories)                     │
│  Доступ к данным, внешние сервисы       │
└─────────────────────────────────────────┘
```

## Слои детально

### 1. Presentation Layer (handlers)

**Ответственность:**
- Обработка HTTP запросов и ответов
- Валидация входных данных
- Сериализация/десериализация JSON
- Обработка ошибок HTTP

**Файлы:**
- `internal/handlers/router.go` - настройка маршрутов
- `internal/handlers/*_handler.go` - обработчики для каждого домена

**Принципы:**
- Handlers не содержат бизнес-логику
- Все запросы проходят через use cases
- Ошибки преобразуются в соответствующие HTTP статусы

### 2. Application Layer (usecases)

**Ответственность:**
- Оркестрация бизнес-логики
- Координация между репозиториями
- Валидация бизнес-правил
- Транзакции (если необходимо)

**Файлы:**
- `internal/usecases/usecases.go` - агрегация всех use cases
- `internal/usecases/*_usecase.go` - конкретные use cases

**Принципы:**
- Use cases зависят только от интерфейсов репозиториев
- Один use case = одна бизнес-операция
- Не зависят от деталей реализации (HTTP, БД и т.д.)

### 3. Domain Layer (models)

**Ответственность:**
- Доменные сущности
- Бизнес-правила и валидация
- Не зависит от внешних слоев

**Файлы:**
- `internal/models/*.go` - доменные модели

**Принципы:**
- Модели не знают о persistence
- Бизнес-логика в методах моделей
- Валидация на уровне модели

### 4. Infrastructure Layer (repositories)

**Ответственность:**
- Реализация доступа к данным
- Взаимодействие с БД через ORM
- Кеширование (если необходимо)

**Файлы:**
- `internal/repositories/repositories.go` - агрегация репозиториев
- `internal/repositories/*_repository.go` - конкретные репозитории

**Принципы:**
- Репозитории реализуют интерфейсы, определенные в use cases
- Используют GORM для работы с БД
- Обработка ошибок БД

## Middleware

Middleware для cross-cutting concerns:

- **Auth** - JWT авторизация
- **Logger** - логирование запросов
- **Recovery** - перехват паник
- **CORS** - настройка CORS
- **Metrics** - сбор Prometheus метрик

## Dependency Injection

Зависимости инжектируются через конструкторы:

```go
// В main.go
repos := repositories.NewRepositories(db)
usecases := usecases.NewUseCases(repos, cfg)
handlers := handlers.NewRouter(usecases, cfg, logger)
```

## Поток данных

```
HTTP Request
    ↓
[Middleware: Logger, CORS, Metrics]
    ↓
[Router]
    ↓
[Handler] → валидация входных данных
    ↓
[UseCase] → бизнес-логика
    ↓
[Repository] → работа с БД
    ↓
[Database]
```

## Модели данных

Основные доменные модели:

- **User, Role** - пользователи и роли
- **Establishment** - заведения
- **Product, TechCard, Ingredient** - меню
- **Order, OrderItem** - заказы
- **Warehouse, Stock, Supply** - склад
- **Shift, Transaction** - финансы
- **Client, Promotion** - маркетинг

## Мониторинг

- **Prometheus** - сбор метрик
- **Grafana** - визуализация метрик и логов
- **Loki** - агрегация логов
- **Promtail** - сбор логов из приложения

## Безопасность

- JWT токены для аутентификации
- Хеширование паролей (bcrypt/argon2)
- Валидация входных данных
- CORS настройки
- SQL injection защита через GORM (prepared statements)

## Тестирование

Структура тестов:

- Unit тесты для use cases
- Integration тесты для репозиториев
- E2E тесты для handlers

## Масштабирование

Архитектура поддерживает:

- Горизонтальное масштабирование (stateless handlers)
- Разделение на микросервисы (если необходимо)
- Кеширование на уровне репозиториев
- Асинхронная обработка через очереди (будущее расширение)